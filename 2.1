class Node:
    """Узел дерева Хаффмана"""

    def __init__(self, char=None, freq=0):
        self.char = char  # Символ (для листьев)
        self.freq = freq  # Частота
        self.left = None  # Левый потомок
        self.right = None  # Правый потомок

    def __lt__(self, other):
        """Сравнение по частоте для кучи"""
        return self.freq < other.freq


class HuffmanTree:
    """Дерево Хаффмана для кодирования"""

    def __init__(self):
        self.root = None  # Корень дерева
        self.codes = {}  # Словарь кодов

    def build_tree(self, text):
        """Построение дерева из текста"""
        if not text:
            return

        # Подсчет частот символов
        freq = {}
        for char in text:
            freq[char] = freq.get(char, 0) + 1

        # Создание узлов для символов
        nodes = []
        for char, count in freq.items():
            nodes.append(Node(char, count))

        # Построение дерева с помощью кучи
        import heapq
        heapq.heapify(nodes)

        # Объединение узлов пока не останется один корень
        while len(nodes) > 1:
            left = heapq.heappop(nodes)  # Самый редкий
            right = heapq.heappop(nodes)  # Второй по редкости

            parent = Node(freq=left.freq + right.freq)
            parent.left = left
            parent.right = right

            heapq.heappush(nodes, parent)

        self.root = nodes[0] if nodes else None # корень деерева
        self._generate_codes(self.root, "")

    def _generate_codes(self, node, current_code):
        """Рекурсивная генерация кодов"""
        if node is None:
            return

        # Для листа сохраняем код
        if node.char is not None:
            self.codes[node.char] = current_code
            return

        # Обход левого (0) и правого (1) поддерева
        self._generate_codes(node.left, current_code + "0")
        self._generate_codes(node.right, current_code + "1")

    def print_tree(self, node=None, level=0, prefix="Root:"):
        """Вывод структуры дерева"""
        if node is None:
            node = self.root
        if node is None:
            return

        indent = " " * (level * 4)
        # Вывод листа или внутреннего узла
        if node.char is not None:
            print(f"{indent}{prefix} '{node.char}' (частота: {node.freq})")
        else:
            print(f"{indent}{prefix} [внутренний узел] (частота: {node.freq})")
            # Рекурсивный вывод потомков
            if node.left:
                self.print_tree(node.left, level + 1, "L:")
            if node.right:
                self.print_tree(node.right, level + 1, "R:")

    def encode_text(self, text):
        """Кодирование текста"""
        encoded = ""
        for char in text:
            if char in self.codes:
                encoded += self.codes[char]
        return encoded

    def calculate_bits(self, text):
        """Подсчет битов для кодирования"""
        return len(self.encode_text(text))


def run():

    # Ввод данных
    alphabet = input("Введите алфавит: ").strip()
    text = input("Введите текст для кодирования: ").strip()

    # Построение дерева
    tree = HuffmanTree()
    tree.build_tree(text)

    # Вывод кодов символов
    print("\nКоды символов:")
    for char, code in sorted(tree.codes.items()):
        print(f"'{char}': {code}")

    # Вывод дерева
    print("\nДерево:")
    tree.print_tree()

    # Подсчет и вывод результатов
    total_bits = tree.calculate_bits(text)
    encoded_text = tree.encode_text(text)
    print(f"\nКоличество битов для кодирования: {total_bits}")
    print(f"Закодированный текст: {encoded_text}")


# Запуск первой задачи
if __name__ == "__main__":
    run()
