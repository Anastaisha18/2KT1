class Node:
    """Узел дерева Хаффмана"""

    def __init__(self, char=None, freq=0):
        self.char = char  # Символ (для листьев)
        self.freq = freq  # Частота
        self.left = None  # Левый потомок
        self.right = None  # Правый потомок

    def __lt__(self, other):
        """Сравнение по частоте для кучи"""
        return self.freq < other.freq


class HuffmanTree:
    """Дерево Хаффмана для кодирования"""

    def __init__(self):
        self.root = None  # Корень дерева
        self.codes = {}  # Словарь кодов

    def build_tree(self, alphabet, text):
        """Построение дерева для алфавита на основе текста"""
        if not alphabet or not text:
            return

        # Подсчет частот только для символов из алфавита
        freq = {}
        for char in text:
            if char in alphabet:  # Учитываем только символы из алфавита
                freq[char] = freq.get(char, 0) + 1

        # Добавляем символы из алфавита, которых нет в тексте (частота = 0)
        for char in alphabet:
            if char not in freq:
                freq[char] = 0

        # Создание узлов для всех символов алфавита
        nodes = []
        for char, count in freq.items():
            nodes.append(Node(char, count))

        # Построение дерева с помощью кучи
        import heapq
        heapq.heapify(nodes)

        # Объединение узлов пока не останется один корень
        while len(nodes) > 1:
            left = heapq.heappop(nodes)  # Минимальный узел
            right = heapq.heappop(nodes)  # Следующий минимальный

            parent = Node(freq=left.freq + right.freq)
            parent.left = left
            parent.right = right

            heapq.heappush(nodes, parent)

        self.root = nodes[0] if nodes else None
        self._generate_codes(self.root, "")

    def _generate_codes(self, node, current_code):
        """Рекурсивная генерация кодов"""
        if node is None:
            return

        # Для листа сохраняем код
        if node.char is not None:
            self.codes[node.char] = current_code
            return

        # Обход левого (0) и правого (1) поддерева
        self._generate_codes(node.left, current_code + "0")
        self._generate_codes(node.right, current_code + "1")

    def print_tree(self, node=None, level=0, prefix="Root:"):
        """Вывод структуры дерева"""
        if node is None:
            node = self.root
        if node is None:
            return

        indent = " " * (level * 4)
        # Вывод листа или внутреннего узла
        if node.char is not None:
            print(f"{indent}{prefix} '{node.char}' (частота: {node.freq})")
        else:
            print(f"{indent}{prefix} [внутренний узел] (частота: {node.freq})")
            # Рекурсивный вывод потомков
            if node.left:
                self.print_tree(node.left, level + 1, "L:")
            if node.right:
                self.print_tree(node.right, level + 1, "R:")

    def encode_text(self, text):
        """Кодирование текста - каждая буква кодируется отдельно"""
        encoded = ""
        for char in text:
            if char in self.codes:
                encoded += self.codes[char]
            else:
                print(f"Предупреждение: символ '{char}' не найден в алфавите")
        return encoded

    def calculate_bits(self, text):
        """Подсчет битов для кодирования"""
        return len(self.encode_text(text))


def task1():
    # Ввод данных
    alphabet = input("Введите алфавит: ").strip()
    text = input("Введите текст для кодирования: ").strip()

    # Построение дерева для всего алфавита
    tree = HuffmanTree()
    tree.build_tree(alphabet, text)

    # Вывод кодов для ВСЕХ символов алфавита
    print("\nКоды для каждой буквы алфавита:")
    for char in sorted(alphabet):  # Сортируем для удобства чтения
        if char in tree.codes:
            print(f"'{char}': {tree.codes[char]}")
        else:
            print(f"'{char}': не удалось сгенерировать код")

    # Вывод дерева
    print("\nДЕРЕВО:")
    tree.print_tree()

    # Кодирование текста и подсчет битов
    total_bits = tree.calculate_bits(text)
    encoded_text = tree.encode_text(text)

    print(f"\nКоличество битов для кодирования текста: {total_bits}")
    print(f"Исходный текст: {text}")
    print(f"Закодированный текст: {encoded_text}")

    # Демонстрация кодирования каждой буквы
    print(f"\nПОБУКВЕННОЕ КОДИРОВАНИЕ:")
    for char in text:
        if char in tree.codes:
            print(f"'{char}' -> {tree.codes[char]}")
        else:
            print(f"'{char}' -> символ не в алфавите")

    # Запуск первой задачи
if __name__ == "__main__":
    task1()
